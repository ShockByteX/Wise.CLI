using Microsoft.CodeAnalysis;
using System.Text;

namespace Wise.CLI.Generator;

internal sealed class CilTemplateBuilder(string ns, string className)
{
    private const string MainTemplate = """
                                        // AutoGenerated
                                        
                                        #nullable enable
                                        
                                        using System;
                                        using System.Globalization;
                                        using System.Text;
                                        
                                        namespace {0};
                                        
                                        public partial class {1}
                                        {{
                                            private static readonly IReadOnlyDictionary<char, string> AliasNameMap = new Dictionary<char, string>
                                            {{
                                        {2}
                                            }};
                                        
                                            public static {1} Parse(string[] args)
                                            {{{5}
                                                var result = new {1}();
                                                string? name = null;
                                        
                                                var setArguments = new HashSet<string>();
                                        
                                                foreach (var arg in args)
                                                {{
                                                    if (name is null)
                                                    {{
                                                        name = ParseName(arg);
                                                        continue;
                                                    }}
                                        
                                                    switch (name)
                                                    {{
                                        {4}
                                                        default:
                                                            throw new ArgumentException($"Unknown command-line argument: {{name}}");
                                                    }}
                                        
                                                    setArguments.Add(name);
                                        
                                                    name = null;
                                                }}
                                        {3}
                                        
                                                return result;
                                            }}{6} 
                                        
                                            private static string ParseName(string arg)
                                            {{
                                                ReadOnlySpan<char> span = arg;
                                         
                                                if (!arg.StartsWith("-", StringComparison.Ordinal))
                                                    throw new ArgumentException($"Invalid command-line argument: {{arg}}");
                                        
                                                bool isAlias;
                                                string? name;
                                        
                                                if (arg.StartsWith("--", StringComparison.Ordinal))
                                                {{
                                                    isAlias = false;
                                                    name = arg[2..];
                                                }}
                                                else
                                                {{
                                                    isAlias = true;
                                                    name = arg[1..];
                                                }}
                                        
                                                if (string.IsNullOrEmpty(name))
                                                    throw new ArgumentException($"Missing command-line argument name: {{arg}}");
                                        
                                                if (isAlias && !AliasNameMap.TryGetValue(arg[1], out name))
                                                    throw new ArgumentException($"Unknown command-line argument: {{name}}");
                                        
                                                return name;
                                            }}
                                        }}
                                        """;

    private const string CaseTemplate = """
                                                        case {0}:
                                                            result.{1} = {2};
                                                            break;
                                        """;

    private const string AliasNameMapEntryTemplate = """        {{ '{0}', "{1}" }}""";

    private const string RequiredTemplate =
        """

                var missing = new[] {{ {0} }}
                    .Where(argument => !setArguments.Contains(argument))
                    .Select(argument => $"--{{argument}}")
                    .ToArray();

                if (missing.Length > 0)
                    throw new ArgumentException($"Missing required arguments: {{string.Join(", ", missing)}}");
        """;

    private readonly List<CilArgumentInfo> _arguments = [];

    public void AddProperty(IPropertySymbol property)
    {
        var attribute = property.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name.Contains(nameof(CliOptionAttribute)) == true);

        if (attribute == null) return;

        var name = attribute.GetArgumentValue<string>(nameof(CliOptionAttribute.Name))!;

        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Command-line option name cannot be null or empty");

        var alias = attribute.GetArgumentValue<char>(nameof(CliOptionAttribute.Alias));
        var required = attribute.GetArgumentValue<bool>(nameof(CliOptionAttribute.Required));
        var description = attribute.GetArgumentValue<string>(nameof(CliOptionAttribute.Description));

        _arguments.Add(new CilArgumentInfo(property, name, alias, required, description));
    }

    public string Build(bool generateHelp)
    {
        var aliasNameMap = new List<string>();
        var requiredArguments = new List<string>();
        var caseBuilder = new StringBuilder();
        var helpBuilder = new CilHelpBuilder(_arguments, generateHelp);

        foreach (var argument in _arguments)
        {
            if (argument.Alias != 0)
                aliasNameMap.Add(string.Format(AliasNameMapEntryTemplate, argument.Alias, argument.Name));

            var quotedName = $"\"{argument.Name}\"";

            if (argument.Required)
                requiredArguments.Add(quotedName);

            var parseExpression = GetParseExpression(argument.Property.Type);
            caseBuilder.AppendLine(string.Format(CaseTemplate, quotedName, argument.Property.Name, parseExpression));

            helpBuilder.AppendArgument(argument);
        }

        var aliasNameMapPart = aliasNameMap.Count > 0
            ? string.Join(", \r\n", aliasNameMap)
            : string.Empty;

        var requiredArgumentsPart = requiredArguments.Count > 0
            ? string.Format(RequiredTemplate, string.Join(", ", requiredArguments))
            : string.Empty;

        var (helpCondition, printHelp) = helpBuilder.Build();

        return string.Format(MainTemplate, ns, className, aliasNameMapPart, requiredArgumentsPart, caseBuilder, helpCondition, printHelp);
    }

    private static string GetParseExpression(ITypeSymbol type)
    {
        if (type.TypeKind is TypeKind.Enum)
            return $"({type.ToDisplayString()})System.Enum.Parse(typeof({type.ToDisplayString()}), arg, ignoreCase: true)";

        return type.SpecialType switch
        {
            SpecialType.System_String => "arg",
            SpecialType.System_Boolean => "bool.Parse(arg)",
            SpecialType.System_Byte => "byte.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_Int16 => "short.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_UInt16 => "ushort.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_Int32 => "int.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_UInt32 => "uint.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_Int64 => "long.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_UInt64 => "ulong.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_Single => "float.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_Double => "double.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_Decimal => "decimal.Parse(arg, CultureInfo.InvariantCulture)",
            SpecialType.System_DateTime => "DateTime.Parse(arg, CultureInfo.InvariantCulture)",
            _ => throw new NotSupportedException($"Type {type.Name} not supported")
        };
    }
}